#!/bin/bash

declare -A projectDic=(
    ["windowLength"]=0 #-w
    ["inputFile"]='' #-i
    ["inputLoc"]=''
    ["outputLoc"]='' #-o
    ["filename"]=''
    ["projectName"]='out' #-p
    ["flanks"]=0 #-f
    ["referenceGenome"]='' #-r
    ["OperationalStage"]='vcfTObed'
    ["JOB"]='NO_JOB_NOW'
)

declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')

starter(){ #grabs the arguments
    DATE=`date +"%m%d%Y-%k%M"`
    local args=("$@")
    if [[ "$#" > 1 ]] && [[ ${args[0],,} != "--help" ]] && [[ ${args[0],,} != "-h" ]]; then
        local frontgate=0
        local indexPos=0
        for i in $@; do
            if [[ "${i,,}" == "-w" ]]; then ##Window expansion size
                local var=${args[${indexPos}+1]}
                if [[ "$var" =~ ^[0-9]+$ ]]; then ##Checks if it's a number, max expansion of 1000.
                    ((projectDic["windowLength"]+="$var"))
                    frontgate=1
                else
                    echo -e "\nPlease enter a valid integer for window expansion size, defaulting to ZERO.\n"
                fi
            elif [[ "${i,,}" == "-i" ]]; then ##Input file which grabs the input file name, location and complete file path 
                local var=${args[${indexPos}+1]}
                if [[ "${var##*.}" == "vcf" ]] && [ -f "$var" ]; then ##Checks if it's VCF and if file exist
                    projectDic["inputFile"]+="$var"
                    projectDic["inputLoc"]+="${var%/*}"
                    local filename=${var%.*}
                    filename=${filename##*/}
                    projectDic["filename"]+="$filename"
                    frontgate=1
                else
                    echo -e "\nERROR. Incorrect file input. Check file or directory path. (Input (.vcf) only)\nEXITING...\n"
                    exit 1
                fi
            elif [[ "${i,,}" == "-o" ]]; then ##output location info
                local var=${args[${indexPos}+1]}
                if [ -d "$var" ]; then ##Checks if directory exist, if not it will save to input file location
                    if [[ "${var: -1}" == "/" ]]; then
                        projectDic["outputLoc"]+="$var"
                    else
                        projectDic["outputLoc"]+="$var"/
                    fi
                    frontgate=1
                fi
            elif [[ "${i,,}" == "-p" ]]; then ##Project name
                local var=${args[${indexPos}+1]}
                projectDic["projectName"]="$var"
                frontgate=1
            elif [[ "${i,,}" == "-f" ]]; then ##Flank sizes for mutation motif's aln_to_counts func
                local var=${args[${indexPos}+1]}
                frontgate=1
                if [[ "$var" =~ ^[0-2]+$ ]]; then ##Checks if it's a number and if it's between 0 and 2
                    ((projectDic["flanks"]+="$var"))
                else
                    echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
                fi
            elif [[ "${i,,}" == "-r" ]]; then ##Which reference genome needed for FASTA file creation
                local var=${args[${indexPos}+1]}
                referenceAssignment ${var}
                frontgate=1
            elif [[ "${i}" == "-JOB" ]]; then
                local var=${args[${indexPos}+1]}
                projectDic["JOB"]="${var}"
            fi
            ((indexPos+=1))
        done
        if ((${frontgate} <= 0)); then
            echo -e "\nPlease enter valid arguments. None where valid.\n"
        fi
        if [[ ${projectDic["inputFile"]} == '' ]]; then
            echo -e "\nNo input file or working directory specified.\nEXITING...\n"
            exit 1
        fi
        if [[ -z ${projectDic["outputLoc"]} ]] && [[ ${projectDic["inputFile"]} != '' ]]; then
            echo -e "\nNot a valid output location. Re-routing to input file location.\n"
            projectDic["outputLoc"]+=${projectDic["inputLoc"]}
        fi
        if [[ ${projectDic["referenceGenome"]} == "" ]]; then
            referenceAssignment
        fi
        mkdir "${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
        projectDic["outputLoc"]="${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
        # mkdir "${projectDic["outputLoc"]}"FASTA_SPLIT
        mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
        mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
        # mkdir "${projectDic["outputLoc"]}"BED_SPLIT
        # echo -e "${projectDic["outputLoc"]}" ###
    else
        local helpPrintOut=$'\n\tSNP context\n\tList of commands:\n\t------------------------\n'
        helpPrintOut+=$'\n\t./SNPcontext -i <input> -o <output> -r <reference genome> -w <expansion size> -f <alignment window flank]> -p <project name>\n'
        helpPrintOut+=$'\n\t------------------------\n'
        helpPrintOut+=$'\n\t-i [File input, VCF only]\n\t-o [output location (defaults to input location if not stated)]'
        helpPrintOut+=$'\n\t-r [Reference genome]\n\t-w [window expansion size]\n\t-f [mutation motif window flank]'
        helpPrintOut+=$'\n\t-p [project name]\n'
        echo "$helpPrintOut"
        exit -0
    fi
}

fastaSpliter(){
    for y in ${dirL[@]}; do
        cp "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic[filename]}".fasta "${projectDic["outputLoc"]}"FASTA_SPLIT/"${y}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
    done
}

referenceAssignment(){
    if [[ ${var,,} == "barley" ]] || [[ ${var,,} == "b" ]]; then ##forced lowercase with ,,
        projectDic["referenceGenome"]+='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    elif [[ ${var,,} == "soy bean" ]] || [[ ${var,,} == "s" ]] || [[ ${var,,} == "soy" ]]; then
        projectDic["referenceGenome"]+="soy/temp/path/to/reference/"
    else
        echo -e "\nPlease enter a valid reference genome. Defaulting to Barley reference.\n"
        projectDic["referenceGenome"]+='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    fi
}

moduleLoader(){ #load modules need for operations

    module load R
    module load python3_ML/3.6.1
    module load bedops_ML/2.4.20
    module load bedtools_ML/2.23.0

}

fileConverter(){
    if [ "${projectDic[OperationalStage]}" == "vcfTObed" ]; then
        vcf2bed < "${projectDic["inputFile"]}" > "${projectDic["outputLoc"]}"/"${projectDic["projectName"]}"_"${projectDic["filename"]}".bed ##sort later
        projectDic["OperationalStage"]="bedTOfasta"
    # elif [ "${projectDic[OperationalStage]}" == "...." ]; then ##OLD CODE, MOST LIKELY WILL REMOVE
    #     local declare -A aln_out
    #     local declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')
    #     temp="${projectDic[outputLoc]}"BED_SPLIT/
    #     splitDir=("${temp}"*_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed*)
    #     for gDir in ${dirL[@]}; do
    #         comSDir="${gDir}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".bed
    #         counter=0
    #         for sp in ${splitDir[@]}; do
    #             if [[ "${splitDir[$counter]##*/}" == "${comSDir}" ]]; then
    #                 bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic["outputLoc"]}"BED_SPLIT/"${comSDir}" -fo "${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
    #                 aln_out+=( ["${gDir}"]="${projectDic[outputLoc]}"FASTA_SPLIT/"${gDir}"_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta )
    #             fi
    #             ((counter+=1))
    #         done
    #     done
    #     projectDic["OperationalStage"]="alnToCounts"
    #     if [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
    #         mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
    #         for d in "${!aln_out[@]}"; do
    #             aln_to_counts --align_path "${aln_out[$d]}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${d}" -F
    #         done
    #         mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
    #         mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
    #         projectDic["OperationalStage"]="DONE..."
    #     fi
    # elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
    #         bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic["filename"]}"_new_interval.bed -fo "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic[filename]}".fasta    
    #         projectDic["OperationalStage"]="alnToCounts"
    # elif [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
    #     local temp="${projectDic[outputLoc]}"FASTA_SPLIT/
    #     local splitDir=("${temp}"*_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta*)
    #     for gDir in ${dirL[@]}; do
    #         local comSDir="${gDir}"_split_"${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
    #         local counter=0
    #         for sp in ${splitDir[@]}; do
    #             if [[ "${splitDir[$counter]##*/}" == "${comSDir}" ]]; then
    #                 aln_to_counts --align_path "${splitDir[$counter]}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${gDir}" -F
    #             fi
    #             ((counter+=1))
    #         done
    #     done
    #     mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
    #     all_counts -c ${projectDic[outputLoc]}COUNTS_TABLES/"*.txt*" -o "${projectDic[outputLoc]}"
    #     projectDic["OperationalStage"]="DONE..." 
    elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
        bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic["filename"]}"_new_interval.bed -fo "${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic[filename]}".fasta    
        projectDic["OperationalStage"]="alnToCounts"
        if [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
            fastaLoc="${projectDic[outputLoc]}""${projectDic["projectName"]}"_"${projectDic[filename]}".fasta
            wcFile="${projectDic["projectName"]}"_"${projectDic[filename]}".txt
                for gDir in ${dirL[@]}; do
                    aln_to_counts --align_path "${fastaLoc}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES --flank_size "${projectDic[flanks]}" --direction "${gDir}" -F
                    mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${wcFile}" "${projectDic[outputLoc]}"COUNTS_TABLES/"${gDir}"_"${wcFile}"
                done
            mv "${projectDic[outputLoc]}"COUNTS_TABLES/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/LOGS
            all_counts -c ${projectDic[outputLoc]}COUNTS_TABLES/"*.txt*" -o "${projectDic[outputLoc]}"
            projectDic["OperationalStage"]="DONE..."
        fi
    fi
}

pythonBEDScanner(){
    inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" python3.6 - <<END_OF_PYTHON
    
import os
from itertools import chain
# import itertools
import datetime

def bedMapper(interval, outputLoc, projectName, filename):
    bedMapper=[]
    masterList=[]
    sub=[] ##FOR BEDMAPPER
    temp=[] ##FOR MASTERLIST
    final=''
    with open(outputLoc + "/" + projectName + "_" + filename + ".bed", "rb") as bed_test: ##Change to input variables
        bedmap=bed_test.read()
        for asii in bedmap:
            element = chr(asii)
            if((element != '\t') and (element != '\n')):
                final = final + element
            elif((element == '\t') and (element != '\n')):
                sub.append(final)
                final=''
                sub.append(element)
            if(element == "\n"):
                sub.append(final)
                sub.append(element)
                sub[2] = str(int(sub[2]) - interval)
                sub[4] = str(int(sub[4]) + interval)
                a = sub[2]
                b = sub[4]
                temp.append(int(a))
                temp.append(int(b))
                temp.sort()
                bedMapper.append(sub)
                masterList.append(temp)
                final=''
                sub=[]
                temp=[]
        return(bedMapper, masterList)

def binaryIntersect(expandedList, interval):
    gateA=True
    gateB=True
    now = datetime.datetime.now()
    results = '\n**********************\nTYPE ONE and TYPE TWO CHECKS FOR: ' + now.strftime("%Y-%m-%d, %H:%M") + '\n----------------------------------------------------\n' ##ADD PROJECT NAME TO THIS
    resultsA = '\n**TYPE ONE: OVERLAPS INTO ORIGINAL SNP**\n------------------------------------\n'
    resultsB = '\n**TYPE TWO: OVERLAPS INTO SNP EXPANSION WINDOWS**\n-------------------------------------\n'
    for i in range(len(expandedList)-1): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0] ##A= left side
            b=expandedList[i][1] ##B= right side
            subTA=expandedList[i+1][0]+interval ##TYPE ONE
            subTB=expandedList[i+1][1]-interval ##TYPE ONE
            subMA=expandedList[i+1][0] ##TYPE TWO
            subMB=expandedList[i+1][1] ##TYPE TWO
            binary=[0,0,0,0]
            binaryMB=[0,0,0,0]
            if(a <= subTA):
                binary[0]=1
            if(a <= subTB):
                binary[1]=1
            if(b >= subTA):
                binary[2]=1
            if(b >= subTB):
                binary[3]=1
            if(a <= subMA): ##
                binaryMB[0]=1
            if(a <= subMB):
                binaryMB[1]=1
            if(b >= subMA):
                binaryMB[2]=1
            if(b >= subMB):
                binaryMB[3]=1
            if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
                gateA=False
                if(binary == [0,1,1,0]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB) + '.'
                elif(binary == [1,1,1,1]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB) + '.'
                elif((binary == [1,1,1,0]) or (binary == [0,1,1,1])):
                    if(binary == [1,1,1,0]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the right, between " + str(b) + " and " + str(subTA) + '.'
                    elif(binary == [0,1,1,1]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the left, between " + str(a) + " and " + str(subTB) + '.' 
            if(interval > 0):
                if((binaryMB != [1,1,0,0]) and (binaryMB != [0,0,1,1])):
                    gateB=False
                    if(binaryMB == [0,1,1,0]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subMA) + "-" + str(subMB) + '.'
                    elif(binaryMB == [1,1,1,1]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subMA) + "-" + str(subMB) + '.'
                    elif((binaryMB == [1,1,1,0]) or (binaryMB == [0,1,1,1])):
                        if(binaryMB == [1,1,1,0]):
                            resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the right, between " + str(b) + " and " + str(subMA) + '.'
                        elif(binaryMB == [0,1,1,1]):
                            resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the left, between " + str(a) + " and " + str(subMB) + '.' 
    if(gateA):
        print("\nNo Type ONE window overlaps detected.\n")
        resultsA+="\nNo Type ONE window overlaps detected.\n"
    else:
        print("\nTYPE ONE OVERLAPS DETECTED.")
    if(gateB):
        print("\nNo Type TWO window overlaps detected.\n")
        resultsB+="\nNo Type TWO window overlaps detected.\n"
    else:
        print("\nTYPE TWO OVERLAPS DETECTED.")
    results += resultsA + "\n" + resultsB + "\n"
    results += "\nEND OF INTERVAL CHECKS.\nXXXXXXXXXXXXXXXXXXXXXX\n"
    if((gateA == True) and (gateB == True)):
        print("\nNO overlaps dectected. Results saved to 'WindowOverlap.txt' in your output directory.\n")
    else:
        print("\nTYPE ONE AND/OR TYPE TWO OVERLAPS DETECTED. Check 'WindowOverlap.txt' in your output directory for saved results.\n")
    with open(outputLoc + "/" + projectName + "_" + "WindowOverlap.txt", 'a+') as window:
        window.write(results)

# def fileSaverTwo(bedMapp, outputLoc, filename, projectName, dirC):
#     if(dirC == None):
#         output="".join(chain.from_iterable(bedMapp))
#         with open(outputLoc + "/" + projectName + "_" + filename + "_new_interval.bed", "w") as newBed: ##Change to input variables
#             newBed.write(output)
#     else:
#         output="".join(chain.from_iterable(bedMapp)) ##
#         with open(outputLoc + "/BED_SPLIT/" + dirC + "_" + "split" + "_" + projectName + "_" + filename + ".bed", "w") as splitBed: ##Change to input variables
#             splitBed.write(output)

# def bedSpliter(bedMapp, outputLoc, filename, projectName):
#     directions=["AtoC","AtoG","AtoT","CtoA","CtoG","CtoT","GtoA","GtoC","GtoT","TtoA","TtoC","TtoG"]
#     for j in directions:
#         masterList=[]
#         for i in range(len(bedMapp)):
#             dirC=bedMapp[i][10] + "to" + bedMapp[i][12]
#             if(dirC == j):
#                 masterList.append(bedMapp[i])
#         if(len(masterList) > 0):
#             fileSaver(masterList, outputLoc, filename, projectName, j)  

def fileSaver(bedMapp, outputLoc, filename, projectName):
        output="".join(chain.from_iterable(bedMapp))
        with open(outputLoc + "/" + projectName + "_" + filename + "_new_interval.bed", "w") as newBed: ##Change to input variables
            newBed.write(output)
        # os.rename(outputLoc + "/" + projectName + "_" + filename + ".bed", outputLoc + "/" + projectName + "_" + filename + "_new_interval.bed")
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    windowLength=int(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    return(outputLoc, filename, windowLength, inputFile, projectName)

def main():
    outputLoc, filename, interval, inputFile, projectName=bashInputs()
    bedmap, masterList=bedMapper(interval, outputLoc, projectName, filename)
    binaryIntersect(masterList, interval)
    fileSaver(bedmap, outputLoc, filename, projectName)
main()

END_OF_PYTHON

}

jobCreator(){
    echo -e "Enter email for PBS job updates: "
    read userEmail
    email="${userEmail}" inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" projectname="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" flanks="${projectDic["flanks"]}" referenceGenome="${projectDic["referenceGenome"]}" python3.6 - <<JOB_CREATED

import os

def job():
    job="#!/usr/bin/env bash\n#PBS -l mem=22gb,nodes=1:ppn=16,walltime=24:00:00\n#PBS -m abe\n#PBS -M " + email + "\n"
    job+="#PBS -N " + projectName + "_" + "SNP-Context" + "\n#PBS -q lab\nset -e\nset -o pipefail\n"
    job+="module load snpcontext/1.0.0\n"
    job+="source snpconext "
    job+= "-i " + inputfile + " "
    job+= "-o " + outputLoc + " "
    job+= "-w " + interval + " "
    job+= "-f " + flank + " "
    job+= "-p " + projectname + " "
    job+= "-r " + reference + " "
    job+= "-JOB THIS_IS_A_JOB"

    with open(outputLoc + projectName + ".job", "w") as jobScript:
        jobScript.write(job)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    email=str(os.environ['email'])
    flanks=int(os.environ['flanks'])
    referenceGenome=str(os.environ['referenceGenome'])
    windowLength=int(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    return(outputLoc, filename, windowLength, inputFile, projectName)
    
JOB_CREATED

echo -e "\njob submited./nEXITING...\n"
source "${projectDic["outputLoc"]}""${projectDic["projectName"]}".job
exit 0

}

mainOne(){
    moduleLoader ##LOADS CORRECT MODULES
    starter "$@" ##ASSIGNS INPUTS TO HASHMAP
    # if [[ "${projectDic["JOB"]}" 1= ]]
    fileConverter ##MAKES BED FILE
    pythonBEDScanner ##EXPANDS BED FILE WINDOWS AND CHECKS FOR OVER LAP
    fileConverter ##CREATES FASTA FILE
    # fastaSpliter ##COPIES MASTER FASTA FILE 12 TIMES FOR ALN_TO_COUNTS
    # fileConverter ##ALN_TO_COUNTS TABLES WHICH ARE FED INTO ALL_COUNTS
    ##DONE...
}

mainOne "$@"