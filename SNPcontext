#!/bin/bash

#    Corey Carter, St. Paul, MN - 09 January 2018
#    This bash script is designed to pull contextual sequence flanking a SNP (variants) from a reference genome.
#    The window size for contextual sequence can be user specificed.
#    The program checks for the presence of more than one variant within user specified windows.

#     A bash dictionary for input parameters

declare -A projectDic=(
    ["windowLength"]=1 #-w
    ["inputFile"]='' #-i
    ["inputLoc"]=''
    ["outputLoc"]='' #-o
    ["filename"]=''
    ["projectName"]='out' #-p
    ["flanks"]=0 #-f
    ["referenceGenomeChar"]=''
    ["referenceGenome"]='' #-r
    ["OperationalStage"]='vcfTObed'
    ["nMax"]=25 ##-n
    ["JOB"]='NO_JOB_NOW'
    ["TempLoc"]=''
    ["tempOut"]=''
    ["allData"]='false' #-ad
    
)

#     A bash list of all possible nucleotide state transitions
declare -a dirL=('AtoC' 'AtoG' 'AtoT' 'CtoA' 'CtoG' 'CtoT' 'GtoA' 'GtoC' 'GtoT' 'TtoA' 'TtoC' 'TtoG')

declare -a active=()

#     Takes user arguments from command line and assigns values to dictionary keys in 'projectDic'
starter(){ #grabs the arguments
    local args=("$@")
    if [[ "$#" > 1 ]] && [[ ${args[0],,} != "--help" ]] && [[ ${args[0],,} != "-h" ]]; then
        local frontgate=0
        local indexPos=0
        for i in $@; do
            if [[ "${i,,}" == "-w" ]]; then ##Window expansion size
                local var=${args[${indexPos}+1]}
                if [[ "$var" =~ ^[0-9]+$ ]]; then ##Checks if it's a number, max expansion of 1000.
                    if (( "$var" >= 1)); then ##Changed from 2 to 1
                        ((projectDic["windowLength"]+="$var"))
                        frontgate=1 
                    fi
                else
                    echo -e "\nPlease enter a valid integer for window expansion size, defaulting to 1 bases or flank size.\n"
                fi
            elif [[ "${i,,}" == "-i" ]]; then ##Input file which grabs the input file name, location and complete file path 
                local var=${args[${indexPos}+1]}
                if [[ "${var##*.}" == "vcf" ]] && [ -f "$var" ]; then ##Checks if it's VCF and if file exist
                    projectDic["inputFile"]+="$var"
                    projectDic["inputLoc"]+="${var%/*}"
                    local filename=${var%.*} ##removes files extension
                    filename=${filename##*/} ##removes file path
                    projectDic["filename"]+="$filename"
                    frontgate=1
                else
                    echo -e "\nERROR. Incorrect file input. Check file or directory path. (Input (.vcf) only)\nEXITING...\n"
                    exit 1
                fi
            elif [[ "${i,,}" == "-o" ]]; then ##output location info
                local var=${args[${indexPos}+1]}
                if [ -d "$var" ]; then ##Checks if directory exist, if not it will save to input file location
                    if [[ "${var: -1}" == "/" ]]; then
                        projectDic["outputLoc"]+="$var"
                    else
                        projectDic["outputLoc"]+="$var"/
                    fi
                    frontgate=1
                fi
            elif [[ "${i,,}" == "-p" ]]; then ##Project name
                local var=${args[${indexPos}+1]}
                projectDic["projectName"]="$var"
                frontgate=1
            elif [[ "${i,,}" == "-f" ]]; then ##Flank sizes for mutation motif's aln_to_counts func
                local var=${args[${indexPos}+1]}
                frontgate=1
                if [[ "$var" =~ ^[0-2]+$ ]]; then ##Checks if it's a number and if it's between 0 and 2
                    ((projectDic["flanks"]+="$var"))
                else
                    echo -e "\nFlanks have to be between: 0 - 2. Defaulting to 0.\n"
                fi
            elif [[ "${i,,}" == "-r" ]]; then ##Which reference genome needed for FASTA file creation
                local var=${args[${indexPos}+1]}
                referenceAssignment ${var}
                frontgate=1
            elif [[ "${i}" == "-JOB" ]]; then
                local var=${args[${indexPos}+1]}
                projectDic["JOB"]="${var}"
            elif [[ "${i,,}" == "-n"  ]]; then
                local var=${args[${indexPos}+1]}
                # if [[ "$var" =~ ^[0-9]+$ ]]; then ##CHECK WITH PETER!!!
                #     if (( "${var}" >= 25  && "$var" <= 100 )); then
                #         ((projectDic["nMax"]+="$var"))
                #     elif (( "${var}" < 25 )); then
                #         echo -e "\nMinimum N threshold is 25. Defaulting to 25% threshold."
                #         ((projectDic["nMax"]+=25))
                #     elif (( "${var}" > 100 )); then
                #         echo -e "\nMaximum N threshold is 100. Defaulting to 100% threshold."
                #         ((projectDic["nMax"]+=100))
                #     fi
                #     frontgate=1                    
                # fi
                if [[ "$var" =~ ^[0-9]+$ ]]; then
                    if (( "${var}" >= 0  && "$var" <= 100 )); then
                        ((projectDic["nMax"]+="$var"))
                    elif (( "${var}" < 0 )); then
                        echo -e "\nMinimum N threshold is 1. Defaulting to 1% threshold."
                        ((projectDic["nMax"]+=1))
                    elif (( "${var}" > 100 )); then
                        echo -e "\nMaximum N threshold is 75. Defaulting to 100% threshold."
                        ((projectDic["nMax"]+=100))
                    fi
                    frontgate=1                    
                fi
            elif [[ "${i,,}" == "-ad"  ]]; then
                local var=${args[${indexPos}+1]}
                projectDic["allData"]="${var,,}"
                frontgate=1
            fi
            ((indexPos+=1))
        done
        if ((${frontgate} <= 0)); then
            echo -e "\nPlease enter valid arguments. None were valid.\n"
        fi
        if [[ ${projectDic["inputFile"]} == '' ]]; then
            echo -e "\nNo input file or working directory specified.\nEXITING...\n"
            exit 1
        fi
        if [[ -z ${projectDic["outputLoc"]} ]] && [[ ${projectDic["inputFile"]} != '' ]]; then
            echo -e "\nNot a valid output location. Re-routing to input file location.\n"
            projectDic["outputLoc"]+=${projectDic["inputLoc"]}
        fi
        if [[ ${projectDic["referenceGenome"]} == "" ]]; then
            referenceAssignment ##Function call
        fi
        if (( ${projectDic["flanks"]} > ${projectDic["windowLength"]} )); then
            # ((projectDic["nMax"]+=25))
            ${projectDic["windowLength"]}=${projectDic["flanks"]}
        fi
    else
        local helpPrintOut=$'\n\tSNP context\n\tList of commands:\n\t------------------------\n'
        helpPrintOut+=$'\nSNPcontext -i <input VCF> -o <output> -r <reference genome> -w <expansion size> -f <flank size> -p <project name> -n <acceptable Indel %> -ad <saved all data>\n'
        helpPrintOut+=$'\n\t------------------------\n'
        helpPrintOut+=$'\n\t**Input arguments can be in ANY order.**\n'
        helpPrintOut+=$'\n\t-i [(complete path to VCF file) (the VCF input file)]\n\t-o [(complete path to location) (The output location, if not entered it will default to the same location as your input file.)]'
        helpPrintOut+=$'\n\t-r [(barley or b, soy bean or s )(Selects the reference genome, defaults to Barley if not specified.)]\n\t-w [(Expansion window size)(The expandable window size around the SNP location, 8 on both ends is the deafult.)]'
        helpPrintOut+=$'\n\t-p [project name]\n\t-n [max percentage of indels allowed in fasta files]'
        helpPrintOut+=$'\n\t-a [(true/false) Do you want all temp files (vcf,bed and fasta) to be saved in your output directory]'
        helpPrintOut+=$'\n\t-f [(number between 0 and 2) (flank size for aln_to_counts)]'
        helpPrintOut+=$'\n\t-n [(number)(The percentage of accepted indels in the FASTA file)]'
        helpPrintOut+=$'\n\t-ad [(true or false) (Which stands for “all data”, this allows you to keep all intermediate files (split VCFs, BED, new interval BEDs, FASTA files)\n\t    that are normally deleted after processing. Defaults to false, which deletes intermedidate files.)]\n'
        echo "$helpPrintOut"
        exit -0
    fi
}

#     Current reference genomes for barley and soybean are hard coded here. For other species or reference updates,
#     this will need to be changed.
referenceAssignment(){
    if [[ ${var,,} == "barley" ]] || [[ ${var,,} == "b" ]]; then ##forced lowercase with ,,
        projectDic["referenceGenomeChar"]+='b'
        projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    elif [[ ${var,,} == "soybean" ]] || [[ ${var,,} == "s" ]] || [[ ${var,,} == "soy" ]]; then
        projectDic["referenceGenomeChar"]+='s'
        projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Soybean/PhytozomeV11/Gmax/assembly/Gmax_275_v2.0.fa'
        # projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Soybean/Wm82_V1/Gmax_189.fa'
    else
        echo -e "\nTTTTTTTTTTTTTTTEEEEEEEEEESSSSSSSSSSSSSTTTTTTTTTTTTTT!!!!!!!!!!!!"
        # echo -e "\nPlease enter a valid reference genome. Defaulting to Barley reference.\n"
        # projectDic["referenceGenomeChar"]+='b'
        # projectDic["referenceGenome"]+='/panfs/roc/groups/9/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
        referenceChecker ${var}
        projectDic["referenceGenomeChar"]+=${var}
    fi
}

#    Loading modules on UMN MSI system. Three of the four are maintained by Morrell Lab (Corey Carter).
#    Will need to be changed for use outside UMN/MSI
moduleLoader(){ #load modules need for operations

    module load python3_ML/3.6.4
    module load bedops_ML/2.4.20
    module load bedtools_ML/2.23.0

}

#    Performing vcf to bed conversion using bedops 'vcf2bed' function
fileConverter(){
    if [ "${projectDic[OperationalStage]}" == "vcfTObed" ]; then ##Key and new input LOCATION
        local temp="${projectDic["tempOut"]}"SPLITVCF/
        local splitDir=("${temp}"*_split_"${projectDic[filename]}".vcf*)
        for gene in "${splitDir[@]}"; do
            local targetVCF="${gene%.*}"
            targetVCF="${targetVCF##*/}"
            vcf2bed < "${gene}" > "${projectDic["tempOut"]}"BED_SPLIT/"${targetVCF}".bed & ##sort later
        done
        wait
        projectDic[OperationalStage]="bedTOfasta"
    #    Takes a reference genome and bed file and generates small fasta files from reference genome intervals
    elif [ "${projectDic[OperationalStage]}" == "bedTOfasta" ]; then
        local temp="${projectDic["tempOut"]}"BED_SPLIT/
        local splitDir=("${temp}"*"${projectDic[filename]}"_new_interval.bed*)
        for gene in "${splitDir[@]}"; do
            local targetBED="${gene%.*}"
            targetBED="${targetBED##*/}"
            targetBED=${targetBED:0:4}
            bedtools getfasta -fi "${projectDic["referenceGenome"]}" -bed "${gene}" -fo "${projectDic["tempOut"]}"FASTA_SPLIT/"${targetBED}"_"${projectDic[filename]}".fasta &
        done
        wait
        projectDic[OperationalStage]="alnToCounts"
    elif [ "${projectDic[OperationalStage]}" == "alnToCounts" ]; then
        local temp="${projectDic["tempOut"]}"FASTA_SPLIT/
        local splitDir=("${temp}"*_"${projectDic[filename]}".fasta*)
        echo -e "creating counts tables..."
        for gene in "${splitDir[@]}"; do
            local countfile="${gene%.*}"
            countfile="${countfile##*/}"
            local geneDirection=${countfile:0:4}
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"
            mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/LOGS
            for loopGene in "${dirL[@]}"; do
                aln_to_counts --align_path "${gene}" --output_path "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/ --flank_size "${projectDic[flanks]}" --direction "${loopGene}" -F > /dev/null
                mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/"${countfile}".txt "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/"${loopGene}"_"${geneDirection^^}"_"${projectDic[filename]}".txt
                mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/*.log* "${projectDic[outputLoc]}"COUNTS_TABLES/"${geneDirection}"/LOGS/"${loopGene}"_"${geneDirection^^}"_"${projectDic[filename]}".log ##FIX Unique Log ID'S            
            done
            active+=("${geneDirection}")
        done
        projectDic["OperationalStage"]="allCounts"
    elif [ "${projectDic[OperationalStage]}" == "allCounts" ]; then
        echo -e "creating combined tables..."
        mkdir "${projectDic[outputLoc]}"COUNTS_TABLES/COMBINED_COUNTS
        for loopGene in "${active[@]}"; do
            cd "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/
            all_counts -c "*.txt*" -o "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/ --strand_symmetric > /dev/null 
            mv "${projectDic[outputLoc]}"COUNTS_TABLES/"${loopGene}"/combined_counts.txt "${projectDic[outputLoc]}"COUNTS_TABLES/COMBINED_COUNTS/"${loopGene}"_combined_counts.txt
        done
        projectDic["OperationalStage"]="DONE..."
    fi

}

#    Creates output directories
dirStructure(){
    DATE=`date +"%m%d%Y-%H%M"`
    mkdir "${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
    projectDic["outputLoc"]="${projectDic["outputLoc"]}""${projectDic["projectName"]^^}"_"${DATE}"/
    mkdir "${projectDic[outputLoc]}"COUNTS_TABLES
    if [[ ${projectDic["allData"]} == "true" ]]; then
        mkdir "${projectDic[outputLoc]}"SPLITVCF
        mkdir "${projectDic[outputLoc]}"FASTA_SPLIT
        mkdir "${projectDic[outputLoc]}"BED_SPLIT
        projectDic["tempOut"]="${projectDic[outputLoc]}"
    elif [[ ${projectDic["allData"]} == "false" ]];then
        projectDic["TempLoc"]+=$(mktemp -d)
        mkdir "${projectDic[TempLoc]}"/SPLITVCF
        mkdir "${projectDic[TempLoc]}"/FASTA_SPLIT
        mkdir "${projectDic[TempLoc]}"/BED_SPLIT
        projectDic["tempOut"]="${projectDic["TempLoc"]}"/
    fi
}

referenceChecker(){
    export ${var} 
    # "${projectDic["referenceGenome"]}"=$(python3.6 - << REF_END
    python3.6 - << REF_END

import os
import csv
import sys

def referenceScanner(ref):
    baseDir = os.environ["HOME"]
    with open(baseDir + "/" + ".reference_config.csv", newline='') as refScan:
        refDic = csv.DictReader(refScan, delimiter=";")
        for row in refDic:
            if(row["Reference_Name"] == ref):      
                return(row.get("Path"))
    userPerf = str(input("\nreference not found, would you like to add a reference genome: "))
    cNum = choices(userPerf)
    if(cNum == 0):
        path = newRef(ref)
        return(path)
    else:
        print("\nexiting SNP context...")
        sys.exit(1)

def choices(userPerf):
    if((userPerf.lower() == "y") or (userPerf.lower() == "yes")):
        return(0)
    else:
        return(1)

def createRef():
    baseDir = os.environ["HOME"]    
    with open(baseDir + "/" + ".reference_config.csv", "w", newline='') as newRef:
        written = csv.writer(newRef, delimiter=";")     
        written.writerow(["Reference_Name", "Path"])
        print("\nReference file created...")
    return(0)

def newRef(ref):
    baseDir = os.environ["HOME"]
    refName = str(input("Would you like to use another access name other than " + ref + " for your key: "))
    cNum = choices(refName)
    if(cNum == 0):
        key = str(input("\nEnter the refernece name (This is what you enter in the parameter. *SPACES IN NAME WILL BE REMOVED*): "))
        key.replace(" ", "")
    else:
        key = ref
    path = str(input("\nPlease enter the complete path to the reference genome (Full path 'pwd -P' and filename): "))
    valid = os.path.isfile(path)
    if(not valid):
        print("\nNot a valid path or file...")
        userPerf = str(input("\nWould you like to try again: "))
        cNum = choices(userPerf)
        if(cNum == 0):
            newRef(ref)
        else:
            print("\nExiting...")
            sys.exit(0)
    with open(baseDir + "/" + ".reference_config.csv", 'a+', newline='') as refScan:
        written = csv.writer(refScan, delimiter=";")
        written.writerow([key,path])
        print("\nPath added and loaded..")
    return(path)

def bashInputs():
    ref = str(os.environ['ref'])
    return(ref)

def main():
    # ref = "Isle_of_Dogs"
    ref = bashInputs()    
    refConfig = os.environ["HOME"] 
    refConfig += "/.reference_config.csv"
    valid = os.path.isfile(refConfig)
    if(not valid):
        print("\nReference config file not found in home dir... Generating new file...")
        createRef()
    seqRef = referenceScanner(ref)
    # return(seqRef)
    print(seqRef)

main()
    
REF_END
}

#    This is Python 3 code embedded in the bash script
#    Expands coverage windows based on user-specified intervals
#    Also checks for "Type One" and "Type Two" overlaps
#    A "Type One overlap" is another SNP within immediate contextual sequence
#    A "Type Two overlap" is another SNP within the expanded flanking contextual sequencing
pythonBEDScanner(){
    inputFile="${projectDic["inputFile"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" interval="${projectDic["windowLength"]}" geneDir="$geneDir" python3.6 - <<END_OF_PYTHON
    
import os
import re
import subprocess
from itertools import chain
import datetime

def bedMapper(interval, outputLoc, projectName, filename, geneDir):
    output = str(subprocess.check_output(['wc', '-m', outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed"]))
    length = re.findall(r'\d+', output)
    length = int(length[0])
    bedMapper=bytearray()
    masterList=[]
    sub=[] ##FOR BEDMAPPER
    temp=[] ##FOR MASTERLIST
    final=''
    with open(outputLoc + "BED_SPLIT/" + geneDir + "_split_" + filename + ".bed", "rb") as bed_test: ##Change to input variables
        for i in range(length):
            element = bed_test.read(1).decode("ascii")
            if((element != '\t') and (element != '\n')):
                final = final + element
            elif((element == '\t') and (element != '\n')):
                sub.append(final)
                final=''
                sub.append(element)
            if(element == "\n"):
                sub.append(final)
                sub.append(element)
                sub[2] = str(int(sub[2]) - interval)
                sub[4] = str(int(sub[4]) + interval)         
                a = sub[2]
                b = sub[4]
                temp.append(int(a))
                temp.append(int(b))
                temp.sort()
                bedMapper.extend(''.join(sub).encode("utf-8"))
                masterList.append(temp)
                final=''
                sub=[] ## was sub=[]
                temp=[] ## was sub=[]
        with open(outputLoc + "BED_SPLIT/" + geneDir + "_" + filename + "_new_interval.bed", "wb") as newBed: ##Change to input variables
            newBed.write(bedMapper)
        return(masterList)

def binaryIntersect(expandedList, interval, outputLoc, projectName, filename, geneDir, baseOut):
    gateA=True
    gateB=True
    now = datetime.datetime.now()
    results = '\n**********************\nTYPE ONE and TYPE TWO CHECKS FOR: ' + geneDir + " ON " + now.strftime("%Y-%m-%d, %H:%M") + '\n----------------------------------------------------\n' ##ADD PROJECT NAME TO THIS
    resultsA = '\n**' + geneDir + ' TYPE ONE: OVERLAPS INTO ORIGINAL SNPs**\n------------------------------------\n'
    resultsB = '\n**' + geneDir + ' TYPE TWO: OVERLAPS INTO SNP EXPANSION WINDOWS**\n-------------------------------------\n'
    for i in range(len(expandedList)-1): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0] ##A= left side
            b=expandedList[i][1] ##B= right side
            subTA=expandedList[i+1][0]-(interval) ##TYPE ONE SWITCHED FROM - TO +
            subTB=expandedList[i+1][1]+(interval) ##TYPE ONE SWITCHED FROM - TO +
            subMA=expandedList[i+1][0] ##TYPE TWO
            subMB=expandedList[i+1][1] ##TYPE TWO
            binary=[0,0,0,0]
            binaryMB=[0,0,0,0]
            if(a <= subTA):
                binary[0]=1
            if(a <= subTB):
                binary[1]=1
            if(b >= subTA):
                binary[2]=1
            if(b >= subTB):
                binary[3]=1
            if(a <= subMA): ##
                binaryMB[0]=1
            if(a <= subMB):
                binaryMB[1]=1
            if(b >= subMA):
                binaryMB[2]=1
            if(b >= subMB):
                binaryMB[3]=1
            if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
                gateA=False
                if(binary == [0,1,1,0]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB) + '.'
                elif(binary == [1,1,1,1]):
                    resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB) + '.'
                elif((binary == [1,1,1,0]) or (binary == [0,1,1,1])):
                    if(binary == [1,1,1,0]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the right, between " + str(b) + " and " + str(subTA) + '.'
                    elif(binary == [0,1,1,1]):
                        resultsA+="\n--TYPE ONE at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subTA) + "-" + str(subTB) + ". on the left, between " + str(a) + " and " + str(subTB) + '.' 
            if((binaryMB != [1,1,0,0]) and (binaryMB != [0,0,1,1])):
                gateB=False
                if(binaryMB == [0,1,1,0]):
                    resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subMA) + "-" + str(subMB) + '.'
                elif(binaryMB == [1,1,1,1]):
                    resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subMA) + "-" + str(subMB) + '.'
                elif((binaryMB == [1,1,1,0]) or (binaryMB == [0,1,1,1])):
                    if(binaryMB == [1,1,1,0]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the right, between " + str(b) + " and " + str(subMA) + '.'
                    elif(binaryMB == [0,1,1,1]):
                        resultsB+="\n--TYPE TWO at : " + str(a) + "-" + str(b) + " is overlapping with " + str(subMA) + "-" + str(subMB) + ". on the left, between " + str(a) + " and " + str(subMB) + '.' 
    if(gateA):
        resultsA+="\nNo Type ONE window overlaps detected.\n"
    if(gateB):
        resultsB+="\nNo Type TWO window overlaps detected.\n"
    results += resultsA + "\n" + resultsB + "\n"
    results += "\nEND OF INTERVAL CHECKS.\nXXXXXXXXXXXXXXXXXXXXXX\n"
    with open(baseOut + projectName + "_" + "WindowOverlap.txt", 'a+') as window:
        window.write(results)
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    interval=int(os.environ['interval'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    geneDir=str(os.environ['geneDir'])
    baseOut=str(os.environ['baseOut'])
    return(outputLoc, filename, interval, inputFile, projectName, geneDir, baseOut)

def main():
    outputLoc, filename, interval, inputFile, projectName, geneDir, baseOut=bashInputs()
    masterList=bedMapper(interval, outputLoc, projectName, filename, geneDir) 
    binaryIntersect(masterList, interval, outputLoc, projectName, filename, geneDir, baseOut)
main()

END_OF_PYTHON

}

jobCreator(){
    echo -e "Enter email for PBS job updates: "
    read userEmail
    email="${userEmail}" nMax="${projectDic["nMax"]}" allData="${projectDic["allData"]}" inputFile="${projectDic["inputFile"]}" outputLoc="${projectDic["outputLoc"]}" projectName="${projectDic["projectName"]}" windowLength="${projectDic["windowLength"]}" flanks="${projectDic["flanks"]}" referenceGenome="${projectDic["referenceGenomeChar"]}" python3.6 - <<JOB_CREATED

import os

def jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax):
    job="#!/bin/bash -l\n\n#PBS -l walltime=24:00:00,nodes=2:ppn=10,mem=20gb\n#PBS -m abe\n#PBS -M " + email + "\n"
    job+="#PBS -N " + projectName + "_" + "SNP-Context" + "\n#PBS -q small\nset -e\nset -o pipefail\n\n"
    job+="#PBS -o " + outputLoc + "_" + projectName + "\n#PBS -e " + outputLoc + "_" + projectName + "\n"
    job+="\nmodule load snpContext/1.0.0\n\n"
    # job+="snpcontext "
    job+="/panfs/roc/groups/9/morrellp/public/Software/SNP_Context/SNPcontext "
    job+= "-i " + inputFile + " "
    job+= "-o " + outputLoc + " "
    job+= "-w " + windowLength + " "
    job+= "-f " + flanks + " "
    job+= "-p " + projectName + " "
    job+= "-r " + referenceGenome + " "
    job+= "-ad " + allData + " "
    job+= "-n " + nMax + " "
    job+= "-JOB THIS_IS_A_JOB"

    with open(outputLoc + projectName + ".job", "w") as jobScript:
        jobScript.write(job)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    email=str(os.environ['email'])
    flanks=str(os.environ['flanks'])
    referenceGenome=str(os.environ['referenceGenome'])
    windowLength=str(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    projectName=str(os.environ['projectName'])
    allData=str(os.environ['allData'])
    nMax=str(os.environ['nMax'])
    return(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax)

def main():
    projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax = bashImport()
    jobScript(projectName, inputFile, windowLength, referenceGenome, flanks, email, outputLoc, allData, nMax)

main()
    
JOB_CREATED

qsub "${projectDic["outputLoc"]}""${projectDic["projectName"]}".job
echo -e "\njob submited.\nEXITING...\n"
exit 0

}

vcfSplit(){
    inputFile="${projectDic["inputFile"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" projectName="${projectDic["projectName"]}" python3.6 - <<VCF_SPLIT_END

import os

def geneDirCreate():
    geneDir={

        'AtoC':bytearray(),
        'AtoG':bytearray(),
        'AtoT':bytearray(),
        'CtoA':bytearray(),
        'CtoG':bytearray(),
        'CtoT':bytearray(),
        'GtoA':bytearray(),
        'GtoC':bytearray(),
        'GtoT':bytearray(),
        'TtoA':bytearray(),
        'TtoC':bytearray(),
        'TtoG':bytearray(),
        'rejected':bytearray(),
        'header':bytearray(),
        
    }
    return(geneDir)

def vcfSegments(inputFile, geneDir):
    with open(inputFile, "rb") as raw:
        sub=[]
        counter=0
        gene=''
        results=''
        for readLine in raw:
            sub.clear()
            gene=''
            results=''
            gate=True
            counter=0
            while((gate == True) and (counter <= len(readLine))):
                element = chr(readLine[counter])
                if((element != '#') or (chr(readLine[0]) != "#")):                                
                    if((element != '\t') and (element != '\n')):
                        results = results + element
                    elif((element == '\t') and (element != '\n')):
                        sub.append(results)
                        sub.append(element)
                        results=''
                    if((element == "\n") or (len(sub) == 9)):
                        gene= str(sub[6]) + "to" + str(sub[8])
                        if gene in geneDir:
                            geneDir[gene].extend(readLine)
                            sub.clear()
                            gate=False
                        else:
                            geneDir['rejected'].extend(readLine)
                            sub.clear()
                            gate=False
                else:
                    geneDir['header'].extend(readLine)
                    gate=False
                counter+=1
    return(geneDir)

def vcfSpliter(geneDir, outputLoc, filename, baseOut):
    for key in geneDir:
        if(geneDir[key]):
            if((key != "rejected") and (key != "header")):
                with open(outputLoc + "SPLITVCF/" + key + "_split_" + filename + ".vcf","ab") as vcfOut:
                    vcfOut.write(geneDir['header'])
                    vcfOut.write(geneDir[key])
            else:
                if(key != "header"):
                    with open(baseOut + "REJECTEDVCFs_" + filename + ".vcf","ab") as vcfOut:
                        vcfOut.write(geneDir['header'])
                        vcfOut.write(geneDir[key])

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    inputFile=str(os.environ['inputFile'])
    filename=str(os.environ['filename'])
    projectName=str(os.environ['projectName'])
    baseOut=str(os.environ['baseOut'])
    return(projectName, inputFile, outputLoc, filename, baseOut)

def main():
    projectName, inputFile, outputLoc, filename, baseOut=bashImport()
    geneDir=geneDirCreate()
    geneDir=vcfSegments(inputFile, geneDir)
    vcfSpliter(geneDir, outputLoc, filename, baseOut)

main()

VCF_SPLIT_END

}

fastaScanner(){

    inputFile="${projectDic["inputFile"]}" flank="${projectDic["flanks"]}" baseOut="${projectDic["outputLoc"]}" outputLoc="${projectDic["tempOut"]}" filename="${projectDic["filename"]}" geneTwo=${geneTwo} geneDirTwo="${geneDirTwo}" nMax="${projectDic["nMax"]}" windowLength="${projectDic["windowLength"]}" python3.6 - <<FASTA_SWEEP
    
from itertools import chain
import os

def fastaMapper(gene):
    with open(gene ,"rb") as fasta:
        fastafile=fasta.read()
        totalN=0
        master=[]
        sub=[]
        final=''
        for counter, i in enumerate(fastafile):
            element=chr(i)
            if(element == 'N'):
                totalN+=1
            if((element != "\n") and (element != ">")):
                final = final + str(element)
            if((element == "\n") and (element != ">")):
                final = final + str(element)
                sub.append(final)
                final=''
            if((element == ">") and (element != "\n")):
                if(sub != []):
                    if(sub[0] != ">"):
                        sub = [u.upper() for u in sub]
                    master.append(sub)
                    sub=[]
                    final=''
                    final = final + str(element)
                else:
                    final = final + str(element)
            if(counter == (len(fastafile)-1)):
                final = final + str(element)
                sub.append(final)
                master.append(sub)
    return(master)

def fastaNpop(subMaster, allRejected, nMax):
    maxP=nMax/100
    newsubMaster=[]
    nMaxList=[]
    for subListing in subMaster:
        totalN = len([x for x in subListing[1] if x == "N"])
        nPercent=totalN/len(subListing[1])
        if(nPercent >= maxP):
            nMaxList.append(subListing)
        else:
            newsubMaster.append(subListing)
    return(newsubMaster, nMaxList)

def fastaBasePop(master, interval, flank):
    allRejected=False
    subMaster=[]
    nList=[]
    if(interval > 2):
        Linterval=interval - flank ##change to 4
        Rinterval=interval - (flank - 1) ##change to 4
    else:
        Linterval=0 ##change to 4
        Rinterval=-1 ##change to 4
    for element in master: ##CHANGE TO SUBTRACT CORRECT DISTANCES
        baseIn = element[1][(Linterval):-(Rinterval)] ##MAYBE add +1 on Rinterval.
        if("N" not in baseIn):
            subMaster.append(element)
        else:
            nList.append(element)
    if(len(subMaster) == 0):
        allRejected=True
    return(subMaster, allRejected, nList)

def fileSaver(subMaster, master, nList, nMaxList, gene, allRejected, baseOut, filename, geneDirTwo, outputLoc):
    if(allRejected != True):
        with open(gene,"w") as newFasta:
            output="".join(chain.from_iterable(subMaster))
            newFasta.write(output)
    else:
        with open(baseOut + "FASTA_SPLIT/" + geneDirTwo + filename + ".fasta","w") as newFasta:
            output="".join(chain.from_iterable(master))
            newFasta.write(output)
        os.rename(outputLoc + "FASTA_SPLIT/" + geneDirTwo + filename + ".fasta", outputLoc + "ALLREJECTED_" + geneDirTwo + "_" + filename + ".fasta")
    if(len(nList) != 0):
        with open(baseOut + "N-BASE_FAILED_FASTAS.fasta","a") as newFasta:
            output="".join(chain.from_iterable(nList))
            newFasta.write(output)
    if(len(nMaxList) != 0):
        with open(baseOut + "N-THRESHOLD_FAILED_FASTAS.fasta","a") as newFasta:
            output="".join(chain.from_iterable(nMaxList))
            newFasta.write(output)

def bashImport():
    outputLoc=str(os.environ['outputLoc'])
    flank=int(os.environ['flank'])
    filename=str(os.environ['filename'])
    gene=str(os.environ['geneTwo'])
    nMax=int(os.environ['nMax'])
    geneDirTwo=str(os.environ['geneDirTwo']) ##GENE Direction
    interval=int(os.environ['windowLength'])
    baseOut=str(os.environ['baseOut'])
    return(flank, outputLoc, filename, gene, geneDirTwo, interval, nMax, baseOut)

def main():
    flank, outputLoc, filename, gene, geneDirTwo, interval, nMax, baseOut = bashImport()
    master=fastaMapper(gene)
    subMaster, allRejected, nList = fastaBasePop(master, interval, flank)
    subMaster, nMaxList = fastaNpop(subMaster, allRejected, nMax)
    fileSaver(subMaster, master, nList, nMaxList, gene, allRejected, baseOut, filename, geneDirTwo, outputLoc)

main()

FASTA_SWEEP

}

main(){
    moduleLoader ##LOADS CORRECT MODULES    
    starter "$@" ##ASSIGNS INPUTS TO HASHMAP
    if [[ "${projectDic["JOB"]}" != "THIS_IS_A_JOB" ]]; then
        inputSize=$( stat -c%s "${projectDic["inputFile"]}")
        if (( "${inputSize}" >= 479000000 )); then ##479MB (in decimal) and 456MB (in binary)
            echo -e "\n(.VCF) over 456Mb, generating job script and submitting operations to MSI."
            jobCreator
        fi
    fi
    dirStructure
    vcfSplit
    fileConverter ##MAKES BED FILE
    local temp="${projectDic["tempOut"]}"BED_SPLIT/
    local splitDir=("${temp}"*_split_"${projectDic[filename]}".bed*)
    for gene in "${splitDir[@]}"; do
        local geneDir="${gene%.*}"
        geneDir="${geneDir##*/}"
        geneDir=${geneDir:0:4} ##BASH IS BASE 1
        pythonBEDScanner "$geneDir" & ##EXPANDS BED FILE WINDOWS AND CHECKS FOR OVER LAP
    done
    wait
    echo -e "\nOverlap checks completed..."
    echo -e "See Overlap results located in 'WindowOverlap.txt' in your main output directory.\n"
    fileConverter ##CREATES FASTA FILE
    local tempTwo="${projectDic["tempOut"]}"FASTA_SPLIT/
    local fastalisting=("${tempTwo}"*_"${projectDic[filename]}".fasta*)
    for geneTwo in "${fastalisting[@]}"; do
        local geneDirTwo="${geneTwo%.*}"
        geneDirTwo="${geneDirTwo##*/}"
        geneDirTwo=${geneDirTwo:0:4}
        fastaScanner "${geneDirTwo}" "${geneTwo}" & ##COPIES MASTER FASTA FILE 12 TIMES FOR ALN_TO_COUNTS
    done
    wait
    fileConverter ##ALN_TO_COUNTS TABLES WHICH ARE FED INTO ALL_COUNTS
    fileConverter ##ALL_COUNTS
    if [[ "${projectDic["allData"]}" == "false"  ]]; then
        local templocation="${projectDic["TempLoc"]}"
        rm -rf "${templocation}"
    fi
    ##Add dropbox intergration
    echo -e "operations completed...\n"
        
}

main "$@"
