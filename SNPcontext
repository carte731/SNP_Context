#!/bin/bash

starter(){ #grabs the arguments
    # windowLength=0
    windowLength=5    
    inputFile=''
    inputLoc=''
    outputLoc=''
    filename=''
    if [ "$#" -ge 1 ]; then
        for i in $@; do
            if [ "${i##*.}" == "vcf" ]; then
                inputLoc=${i%/*}
                inputFile=$i
            elif [[ -d "$i" && ! -e "$i" ]]; then
                outputLoc=$i
            else
                # windowLength=$i
                windowLength=5
            fi
        done
        if [ -z "$filename" ]; then
            arg1=$1
            filename=${arg1%.*}
            filename=${filename##*/}
        fi
        if [ -z "$outputLoc" ]; then
            outputLoc=${inputFile%/*}
        fi
        gate="vcfTObed"
    else
        echo -e "\nNo file or working directory specified."
        echo -e "EXITING...\n"
        exit 1
    fi
}

moduleLoader(){ #load modules need for operations

    module load R
    module load gatk_ML/3.8.0
    module load vcftools_ML/0.1.14
    # module load python3_ML/2.7.13
    module load python3_ML/3.6.1
    module load bedops_ML/2.4.20
    module load bedtools_ML/2.23.0

}

fileConverter(){
    referenceGenome='/home/morrellp/shared/References/Reference_Sequences/Barley/Morex/barley_RefSeq_v1.0/150831_barley_pseudomolecules.fasta'
    if [ "$gate" == "vcfTObed" ]; then
        vcf2bed < "${inputFile}" > "${outputLoc}"/"${filename}".bed
        gate="bedTOfasta"
    elif [ "$gate" == "bedTOfasta" ]; then
        bedtools getfasta -fi "${referenceGenome}" -bed "${outputLoc}"/sorted-"${filename}".bed -fo "${outputLoc}"/"${filename}".fasta 
    fi
}

pythonBEDScanner(){
    inputFile="$inputFile" outputLoc="$outputLoc" filename="$filename" windowLength="$windowLength" python3.6 - <<END_OF_PYTHON
    
import os
from itertools import chain
# import itertools
import datetime

def bedMapper(filename, outputLoc):
    bedMap=[]
    with open(outputLoc + "/" + filename + ".bed", "r") as bed_test: ##Change to input variables
        for i in bed_test:
            sub=[]
            final=''
            for u in i:
                if((u != '\t') and (u != "\n")):
                    final = final + str(u)
                else:
                    sub.append(final)
                    final=''
                    sub.append(u)
            bedMap.append(sub)
    return(bedMap)

def intervalLister(bedMap):
    masterList=[]
    for i in range(len(bedMap)):
        temp=[]
        temp.append(int(bedMap[i][4]))
        temp.append(int(bedMap[i][2]))
        temp.sort()
        masterList.append(temp)
    return(masterList)

def intervalExpander(bedMap, interval):
    masterList=intervalLister(bedMap)
    for i in range(len(bedMap)):
        if((bedMap[i][2]) and (bedMap[i][4])):
            try:
                if((type(int(bedMap[i][2])) == int) and (type(int(bedMap[i][4])) == int)):
                    bedMap[i][2] = str(int(bedMap[i][2]) - interval)
                    bedMap[i][4] = str(int(bedMap[i][4]) + interval)
            except:
                print("\nPython interval expanson error on line: " + bedMap.index(i) + ". Adding error notation to error logs")
                #Add stuff for logging error to text file
    expandedList=intervalLister(bedMap)
    return(bedMap, masterList, expandedList)

def fileSaver(bedMapp, outputLoc, filename):
    output="".join(chain.from_iterable(bedMapp))
    with open(outputLoc + "/" + filename + "_new_interval.bed", "w") as newBed: ##Change to input variables
        newBed.write(output)

def typeOneTwo(expandedList, inputList, interval, outputLoc):
    now = datetime.datetime.now()
    gate=True
    typeOT = "ONE"
    results = '\nType One and Two Checks for: ' + now.strftime("%Y-%m-%d, %H:%M") + '\n---------------\n' ##ADD PROJECT NAME TO THIS    
    if(typeOT == "ONE"):
        results += '\nType One: overlap into SNP\n------------------\n'
        for i in range(len(expandedList)): #Checks for Type One SNP overlaps (ORIGINAL INTERVAL CHECK)
            a=expandedList[i][0]
            b=expandedList[i][1]
            comparisonA=a+interval
            comparisonB=b-interval
            for j in range(len(inputList)):
                subMA=inputList[j][0]
                subMB=inputList[j][1]
                if((comparisonA != subMA) and (comparisonB != subMB)): ##Add id() check
                    if(i != J):
                        gate, tempResults=binaryIntersect(binary, typeOT, a, b, subMA, subMB)
                        results+=tempResults
        results += "\n-----\n"
        typeOT="TWO"
        if(gate):
            results+="\nNo " + typeOT + " window overlaps detected.\n"
        gate=True
    if(typeOT == "TWO"): #Checks for Type Two window overlaps (EXTENDED INTERVAL CHECK)
        for i in range(len(expandedList)):
            a2=expandedList[i][0]
            b2=expandedList[i][1]
            for j in range(i+1, len(expandedList)):
                subEA=expandedList[j][0]
                subEB=expandedList[j][1]
                gate, tempResults=binaryIntersect(binary, typeOT, a2, b2, subEA, subEB)
                results+=tempResults
        if(gate):
            results+="\nNo " + typeOT + " window overlaps detected.\n"
    results += "\nEND OF INTERVAL CHECKS.\n**********************\n"
    print(results)
    print("\nCheck 'WindowOverlap.txt' in your output directory for saved results.\n")
    with open(outputLoc + "/WindowOverlap.txt", 'a+') as window: ##CHANGE TO OUTPUT DIR
            window.write(results)

def binaryIntersect(BinaryNum, typeOT, a, b, subTA, subTB):
    resultsBI=''
    binary=[0,0,0,0]
    if(a <= subTA):
        binary[0]=1 
    if(a <= subTB):
        binary[1]=1
    if(b >= subTA):
        binary[2]=1
    if(b >= subTB):
        binary[3]=1
    if((binary != [1,1,0,0]) and (binary != [0,0,1,1])):
        gate=False
        if(BinaryNum == [0,1,1,0]):
            resultsBI+="\n--TYPE " + typeOT + "at :" + str(a) + "-" + str(b) + " SNP is encapsulated within " + str(subTA) + "-" + str(subTB)
        elif(BinaryNum == [1,1,1,1]):
            resultsBI+="\n--TYPE " + typeOT + " at: " + str(a) + "-" + str(b) + " is equal or encapsulating " + str(subTA) + "-" + str(subTB)
        elif((BinaryNum == [1,1,1,0]) or (BinaryNum == [0,1,1,1])):
            if(BinaryNum == [1,1,1,0]):
                resultsBI+="\n--TYPE " + typeOT + " at: " + str(a) + "-" + str(b) + " SNP window is overlapping " + str(subTA) + "-" + str(subTB) + ". Overlaps occurring on the right of SNP, between " + str(b) + " and " + str(subTA)
            elif(BinaryNum == [0,1,1,1]):
                resultsBI+="\n--TYPE " + typeOT + " at: " + str(a) + "-" + str(b) + " SNP window is overlapping " + str(subTA) + "-" + str(subTB) + ". Overlaps occurring on the left of SNP, between " + str(a) + " and " + str(subTB)
    return(gate, resultsBI)
        
def bashInputs():
    outputLoc=str(os.environ['outputLoc'])
    filename=str(os.environ['filename'])
    windowLength=int(os.environ['windowLength'])
    inputFile=str(os.environ['inputFile'])
    return(outputLoc, filename, windowLength, inputFile)

def main():
    completedOne=[]
    outputLoc, filename, interval, inputFile=bashInputs()
    bedMap=bedMapper(filename, outputLoc)
    bedMap, masterList, expandedList=intervalExpander(bedMap, interval)
    fileSaver(bedMap, outputLoc, filename)
    typeOneTwo(expandedList, masterList, interval, outputLoc)

main()

END_OF_PYTHON

}

mainOne(){
    moduleLoader
    starter "$@"
    fileConverter "$inputFile" "$outputLoc" "$filename" "$gate"
    pythonBEDScanner "$inputFile" "$outputLoc" "$filename" "$windowLength"
    fileConverter "$inputFile" "$outputLoc" "$filename" "$gate"
}

mainOne "$@"